#!/usr/bin/env ruby

require 'parslet'
require 'singleton'
require 'digest/md5'
require 'fileutils'
require 'tempfile'
require 'pathname'
require 'set'
require_relative 'c_parse'

## INITIAL PARSER ##############################################################

class GarlicParser < Parslet::Parser
  rule(:space)     { match('\s').repeat(1) }
  rule(:space?)    { space.maybe }

  rule(:float)     {
    (
      match('[+-]').maybe >>
        match('[0-9]').repeat(1) >>
        str('.') >>
        match('[0-9]').repeat(1) >>
        (
          match('[eE]') >>
            match('[+-]').maybe >>
            match('[0-9]').repeat(1)
        ).maybe
    ).as(:float)
  }

  rule(:hex)       { (str('0x') >> match('[0-9a-fA-F]').repeat(1)).as(:hex) }
  rule(:int)       { (match('[+-]').maybe >> match('[0-9]').repeat(1)).as(:int) }
  rule(:bool)      { str('#t').as(:true) | str('#f').as(:false) }

  rule(:simplevar) {
    match('[A-Za-z\-\+\*\/_=<>]') >>
      match('[A-Za-z\-\+\*\/_\?0-9=<>]').repeat(1).maybe
  }

  rule(:var)       {
    ((simplevar >> str(':') >> simplevar) | simplevar).as(:var)
  }

  rule(:list)      {
    str('(') >>
      space? >>
      # Make sure to use .repeat(0, 1) instead of .maybe, since we always want
      # a list in the parse tree, regardless of whether it matched one sub-
      # expression or more.
      (expr >> (space >> expr).repeat(1).maybe).repeat(0, 1).as(:list) >>
      space? >>
      str(')')
  }

  rule(:dotlist)   {
    str('(') >>
      space? >>
      # Make sure to use .repeat(0, 1) instead of .maybe, since we always want
      # a list in the parse tree, regardless of whether it matched one sub-
      # expression or more.
      (
        (expr >> (space >> expr).repeat(1).maybe).repeat(0, 1) >>
        space >> str('.') >> space >>
        expr
      ).as(:dotlist) >>
      space? >>
      str(')')
  }

  rule(:quoted)     {
    str('\'') >> (atom | dotlist | list).as(:quoted)
  }

  rule(:string)     {
    str('"') >>
      (
        (str('\\') >> any) |
        (str('"').absent? >> any)
      ).repeat(1).maybe.as(:string) >>
      str('"')
  }

  rule(:comment)    {
    str(';') >> match('[^\n]').repeat(1).maybe.as(:comment) >> str("\n")
  }

  rule(:atom)      { float | hex | int | bool | var }
  rule(:expr)      { atom | list | dotlist | quoted | string | comment }
  rule(:expr_list) { ((space? >> expr).repeat(1).maybe >> space?).as(:exprs) }

  root(:expr_list)
end

## AST GENERATION ##############################################################

module AST
  class ParseException < Exception; end

  class ProgramModule
    MODULE_TYPE_GARLIC = :garlic
    MODULE_TYPE_C      = :c

    def initialize(filename,
                   module_name,
                   is_main,
                   module_type,
                   ast,
                   child_modules)
      @filename = filename
      @module_name = module_name
      @is_main = is_main
      @module_type = module_type

      @ast = ast
      @child_modules = child_modules
    end

    attr :filename,
         :module_name,
         :is_main,
         :module_type

    attr :ast,
         :child_modules
  end

  module CommonTransformations
    def with_hoisted_definitions(statements)
      defines = statements.find_all { |s| s.is_a?(Definition) }
      others  = statements.reject   { |s| s.is_a?(Definition) }

      defines + others
    end

    def def_names_from_statements(statements)
      statements
        .find_all { |s| s.is_a?(Definition) }
        .map(&:name)
        .map(&:name)
    end
  end

  RequireSpec = Struct.new(
    :absolute_path,
    :basename,
    :nickname,
    :star
  )

  class GarlicModule
    include CommonTransformations

    # These names are available in all scopes. For the most part, these special
    # names have been avoided in favor of defining names in the core and stdlib
    # modules. However, some names can't be defined this way.
    GLOBAL_NAMES = [
      # The command line arguments are only available in the "main" function of
      # a C or assembly program, so it's not possible to define it in a
      # library, even one that's available in every program.
      :"*argv*"
    ]

    def initialize(*statements)
      @statements = statements
    end

    # The standard library file is handled slightly differently than the other
    # modules. In particular, other modules implicitly import everything from
    # stdlib, but the stdlib module shouldn't do that!
    def is_stdlib
      filename == stdlib_filename
    end

    def static_transformed(included_modules)
      unless is_stdlib
        # (require stdlib *)
        @statements.unshift(
          NestedNode.new(
            Var.new(:require),
            Var.new(:stdlib),
            Var.new(:*)
          )
        )
      end

      # It's safe to always include "core" because it is a C module, meaning it
      # will never end up importing itself.
      #
      # (require core *)
      @statements.unshift(
        NestedNode.new(
          Var.new(:require),
          Var.new(:core),
          Var.new(:*)
        )
      )

      @included_modules = included_modules

      @statements, module_requires = separated_module_requires(@statements)
      @statements, module_exports = separated_module_exports(@statements)
      @statements = @statements.map(&:static_transformed)
      @statements = with_hoisted_definitions(@statements)

      compute_names_in_scope

      @module_requires = gathered_requires(module_requires)
      @recursive_requires = recursive_require_modules(@module_requires)

      @module_exports = gathered_exports(module_exports)

      self
    end

    def recursive_require_modules(module_requires)
      module_requires.map { |exp|
        name = exp.absolute_path

        if File.file?("#{name}.scm")
          filename = "#{name}.scm"
          next if @included_modules.include?(filename)

          gather_asts(
            filename,
            name,
            false,
            ProgramModule::MODULE_TYPE_GARLIC,
            @included_modules
          )
        elsif File.file?("#{name}.c")
          filename = "#{name}.c"
          next if @included_modules.include?(filename)

          gather_asts(
            filename,
            name,
            false,
            ProgramModule::MODULE_TYPE_C,
            @included_modules
          )
        else
          raise ParseException.new("required module not found: #{name}")
        end
      }.compact.uniq { |m| m.filename }
    end

    def separated_module_requires(statements)
      separated_statements_of_type(:require)
    end

    def separated_module_exports(statements)
      separated_statements_of_type(:'module-export')
    end

    def separated_statements_of_type(type)
      statements.partition { |statement|
        statement.is_a?(NestedNode) &&
          !statement.children.empty? &&
          statement.children[0].is_a?(Var) &&
          statement.children[0].name == type
      }.reverse
    end

    def gathered_requires(module_exports)
      module_exports.map { |exp|
        name = exp.children[1]

        if name.is_a?(Var)
          basedir = includes_dir
          abs_path = absolute_path_for_module(name.name.to_s, basedir)
        elsif name.is_a?(String)
          basedir = File.dirname(self.filename)
          abs_path = absolute_path_for_module(name.contents, basedir)
        else
          raise ParseException.new("require with invalid name: #{name}")
        end

        basename = File.basename(abs_path)

        if exp.children.size == 3
          star_symbol = exp.children[2]

          unless star_symbol.is_a?(Var) and star_symbol.name == :*
            raise ParseException.new(
              "invalid require qualifier: #{star_symbol}")
          end

          nickname = nil
          star = true
        elsif exp.children.size == 4
          arrow = exp.children[2]
          nickname = exp.children[3]

          unless arrow.is_a?(Var) and arrow.name == :'=>'
            raise ParseException.new("renamed require must include =>")
          end

          unless nickname.is_a?(Var)
            raise ParseException.new(
              "renamed require has invalid nickname: #{nickname}")
          end

          nickname = nickname.name
          star = false
        else
          nickname = nil
          star = false
        end

        RequireSpec.new(
          abs_path,
          basename,
          nickname,
          star
        )
      }
    end

    def compute_external_symbols_in_namespace(require_specs, all_modules)
      fn_to_module = require_specs
        .find_all(&:star)
        .map(&:absolute_path)
        .map { |path|
          all_modules.find { |mod|
            mod.module_name == path
          }
        }
        .map { |mod|
          mod
            .ast
            .module_exports
            .map { |exp|
              [exp, mod]
            }
        }
        .flatten(1)

      keys = fn_to_module
        .map(&:first)

      dups = keys
        .find_all { |sym| keys.count(sym) > 1 }
        .uniq

      unless dups.empty?
        raise GarlicModule::CompileException.new(
          "multiple imported symbols with the same name: " + dups.join(", "))
      end

      # At this point, the keys are exported functions, and the values are
      # the module from which they were exported.
      @external_symbols_in_namespace = Hash[fn_to_module]
    end

    def gathered_exports(module_exports)
      module_exports.map { |exp|
        exp
          .children
          .drop(1)
          .reject { |child| child.is_a?(Comment) }
          .map(&:name)
      }.flatten
    end

    def compute_names_in_scope
      def_names = def_names_from_statements(@statements)
      @names_in_scope = GLOBAL_NAMES | def_names

      @statements.each do |statement|
        statement.compute_names_in_scope(@names_in_scope)
      end
    end

    def to_s
      @statements.join("\n")
    end

    attr :statements
    attr_accessor :filename,
      :recursive_requires,
      :module_requires,
      :module_exports,
      :external_symbols_in_namespace
  end

  class CModule
    def initialize(filename, module_name)
      module_base_name = File.basename(module_name)
      @c_exports = CParser::parse_c_exports_from_string(
        module_base_name,
        File.read(filename)
      )

      @module_exports = @c_exports
        .map(&:name)
        .map(&:intern)
    end

    attr_accessor :module_exports
  end

  class Node
    def has_children?
      false
    end

    def static_transformed
      self
    end

    def specialized_quoted
      self
    end

    def compute_names_in_scope(parent_names)
      @names_in_scope = parent_names

      if has_children?
        children.each do |child|
          child.compute_names_in_scope(@names_in_scope)
        end
      end
    end

    # Can this syntax element be used as an lvalue in a binding operation, such
    # as a `let`? Most syntax elements can only be used as rvalues.
    def can_be_used_as_binding?
      false
    end

    attr_accessor :names_in_scope
  end

  class Comment < Node
    def initialize(text)
      @text = text
    end

    def to_s
      "\033[32m;#{text}\033[0m"
    end

    attr :text
  end

  class Quoted < Node
    def initialize(value)
      @value = value
    end

    def static_transformed
      specialized_quoted
    end

    def specialized_quoted
      @value.specialized_quoted
    end

    def to_s
      "'#{value}"
    end

    attr :value
  end

  class String < Node
    def initialize(contents)
      @contents = contents
    end

    def to_s
      "\033[1;32m\"#{@contents}\"\033[0m"
    end

    attr :contents
  end

  class QuotedAtom < Node
    def initialize(name)
      @name = name
    end

    def to_s
      "\033[1;32m'#{name}\033[0m"
    end

    attr :name
  end

  class QuotedList < Node
    def initialize(is_nil_terminated, children)
      @is_nil_terminated = is_nil_terminated
      @children = children
    end

    def has_children?
      true
    end

    def to_s
      children_list = @children.map(&:to_s)

      if is_nil_terminated
        last_child = children_list.pop
        children_list << "."
        children_list << last_child
      end

      children_str = children_list.join(" ")
      "'(#{children_str})"
    end

    attr :is_nil_terminated, :children
  end

  class Nil < Node
    include Singleton

    def to_s
      "'()"
    end
  end

  class Var < Node
    def initialize(name)
      @name = name
    end

    def to_s
      @name.to_s
    end

    def specialized_quoted
      QuotedAtom.new(@name)
    end

    def can_be_used_as_binding?
      true
    end

    attr :name
  end

  class IntVal < Node
    def initialize(value)
      @value = value
    end

    def to_s
      @value.to_s
    end

    def specialized_quoted
      self
    end

    attr :value
  end

  class FloatVal < Node
    def initialize(value)
      @value = value
    end

    def to_s
      @value.to_s
    end

    def specialized_quoted
      self
    end

    attr :value
  end

  class TrueVal < Node
    include Singleton

    def to_s
      "#t"
    end

    def specialized_quoted
      self
    end
  end

  class FalseVal < Node
    include Singleton

    def to_s
      "#f"
    end

    def specialized_quoted
      self
    end
  end

  class SpecializedNode < Node
    def has_children?
      true
    end
  end

  class NestedNode < Node
    def initialize(*children)
      @children = children
    end

    def has_children?
      true
    end

    def static_transformed
      filtered_children = @children.reject { |child| child.is_a?(Comment) }

      if filtered_children.empty?
        # The only time an empty list is valid is when it's quoted, i.e. when
        # it represents "nil". If that's the case, it will be handled by
        # "specialized_quoted", not by "static_transformed".
        raise ParseException.new("empty list is invalid without quoting")
      else
        first = filtered_children.first
        first_is_var = first.is_a?(Var)

        specialized =
          if first_is_var
            case first.name
            # If we find a require or a module-export, it means it was not
            # removed by the relevant pre-processing step, which only looks at
            # the top-level statements. Thus, this statement is nested, which
            # is illegal.
            when :require
              raise ParseException.new("require found in nested scope")
            when :'module-export'
              raise ParseException.new("module-export found in nested scope")
            when :define
              Definition.new(*filtered_children)
            when :lambda
              Lambda.new(*filtered_children)
            when :begin
              Begin.new(*filtered_children)
            when :if
              If.new(*filtered_children)
            when :cond
              Cond.new(*filtered_children)
            when :and
              And.new(*filtered_children)
            when :or
              Or.new(*filtered_children)
            when :let
              Let.new(:bare, *filtered_children)
            when :'let*'
              Let.new(:star, *filtered_children)
            when :letrec
              Let.new(:rec, *filtered_children)
            else
              as_function_call(filtered_children)
            end
          else
            as_function_call(filtered_children)
          end

        specialized.static_transformed
      end
    end

    def as_function_call(filtered_children)
      FunctionCall.new(*filtered_children)
    end

    def specialized_quoted
      if @children.empty?
        Nil.instance
      else
        quoted_children = @children.map(&:specialized_quoted)
        QuotedList.new(false, quoted_children)
      end
    end

    def internal_color
      "1;32"
    end

    def to_s
      children_str = @children.map { |child|
        if child.has_children?
          child.to_s
        else
          "\033[#{self.internal_color}m#{child}\033[0m"
        end
      }.join(" ")

      "(#{children_str})"
    end

    def can_be_used_as_binding?
      children.all? { |child| child.can_be_used_as_binding? }
    end

    attr :children
  end

  class DottedList < NestedNode
    def initialize(*children)
      @children = children
    end

    def has_children?
      true
    end

    def static_transformed
      # A dotted list never appears on its own. There are two cases where a
      # dotted list are encountered:
      #
      #  - In a special form, such as in the argument list of a function
      #    definition. These situations are handled specially by the parent
      #    node's static transformation.
      #
      #  - In a quoted list, which is taken care of by "specialized_quoted".
      raise ParseException.new("invalid dotted list")
    end

    def specialized_quoted
      quoted_children = @children.map(&:specialized_quoted)
      QuotedList.new(true, quoted_children)
    end

    def internal_color
      "1;32"
    end

    def to_s
      children_list = @children.map { |child|
        if child.has_children?
          child.to_s
        else
          "\033[#{self.internal_color}m#{child}\033[0m"
        end
      }

      last_child = children_list.pop
      children_list << "."
      children_list << last_child

      children_str = children_list.join(" ")
      "(#{children_str})"
    end

    attr :children
  end

  class SpecializedNode < Node
    def has_children?
      true
    end
  end

  class Definition < SpecializedNode
    def initialize(*children)
      @children = children
    end

    def static_transformed
      if @children[1].is_a?(Var)
        unless @children.size == 3
          raise ParseException.new(
            "Variable definition must have 3 children, " +
              "got #{@children.size}: " +
              "(#{@children.join(" ")})")
        end

        @name = @children[1]
        @value = @children[2].static_transformed
      elsif @children[1].is_a?(NestedNode)
        unless @children.size >= 3
          raise ParseException.new(
            "Variable definition must have at least 3 children, " +
              "got #{@children.size}: " +
              "(#{@children.join(" ")})")
        end

        signature = @children[1].children

        if signature.empty?
          raise ParseException.new("Definition must have a name")
        end

        @name = signature[0]

        params_array = signature.drop(1)
        if @children[1].is_a?(DottedList)
          params = DottedList.new(*params_array)
        else
          params = NestedNode.new(*params_array)
        end

        @value = Lambda.new(
          :lambda,
          params,
          *@children.drop(2)
        ).static_transformed
      else
        raise ParseException.new(
          "Definition name must be a var or list, got: " +
            "#{@children[1]} of type #{@children[1].class}")
      end

      self
    end

    def compute_names_in_scope(parent_names)
      @names_in_scope = parent_names

      @name.compute_names_in_scope(@names_in_scope)
      @value.compute_names_in_scope(@names_in_scope)
    end

    def to_s
      "(\033[#{self.internal_color}mdefine\033[0m " +
        "\033[1m#{@name}\033[0m #{@value})"
    end

    def internal_color
      "1;31"
    end

    attr :name, :value, :children
  end

  class Lambda < SpecializedNode
    include CommonTransformations

    def initialize(*children)
      @children = children
    end

    def static_transformed
      unless @children.size >= 3
        raise ParseException.new(
          "Lambda must have at least 3 children, got #{@children.size}: " +
            "(#{@children.join(" ")})")
      end

      unless @children[1].is_a?(Var) or @children[1].has_children?
        raise ParseException.new(
          "Lambda parameter list must be a var or list, got: " +
            "#{@children[1]} of type #{@children[1].class}")
      end

      if @children[1].has_children?
        @children[1].children.each do |param|
          unless param.is_a?(Var)
            raise ParseException.new(
              "Lambda parameter must be a var, got: " +
                "#{param} of type #{param.class}")
          end
        end
      end

      if @children[1].is_a?(DottedList)
        @params = @children[1].children.take(@children[1].children.size - 1)
        @rest_param = @children[1].children.last
        @is_vararg = true
      elsif @children[1].is_a?(Var)
        @params = []
        @rest_param = @children[1]
        @is_vararg = true
      else
        @params = @children[1].children
        @rest_param = nil
        @is_vararg = false
      end

      @body_statements = @children[2, children.length - 1]
        .map(&:static_transformed)
      @body_statements = with_hoisted_definitions(@body_statements)

      self
    end

    def compute_names_in_scope(parent_names)
      @names_in_scope = parent_names

      @params.each do |param|
        param.compute_names_in_scope(@names_in_scope)
      end
      @rest_param.compute_names_in_scope(@names_in_scope) if @rest_param

      param_names = @params.map(&:name)
      param_names << @rest_param.name if @rest_param

      body_def_names = def_names_from_statements(@body_statements)

      names_in_body_scope = Set.new(@names_in_scope)
      names_in_body_scope.merge(param_names)
      names_in_body_scope.merge(body_def_names)

      @body_statements.each do |statement|
        statement.compute_names_in_scope(names_in_body_scope)
      end
    end

    def to_s
      "(\033[#{self.internal_color}mlambda\033[0m " +
        "(\033[1m#{@params.join(" ")}\033[0m)\n" +
        @body_statements.map(&:to_s).map { |s| "\t#{s}" }.join("\n") + ")"
    end

    def internal_color
      "1;33"
    end

    attr :params, :rest_param, :is_vararg, :body_statements, :children
  end

  class Begin < SpecializedNode
    def initialize(*children)
      @expressions = children.drop(1)
    end

    def static_transformed
      raise ParseException.new('begin block must have at least one child') \
        if @expressions.empty?

      @expressions = @expressions.map(&:static_transformed)

      self
    end

    def compute_names_in_scope(parent_names)
      @names_in_scope = parent_names
      @expressions.each do |expr|
        expr.compute_names_in_scope(@names_in_scope)
      end
    end

    def to_s
      expressions_str = @expressions_str
        .map {|expr| "  #{expr}"}
        .join("\n")

      "(\033[#{self.internal_color}mbegin\n#{expressions_str}\033[0m)"
    end

    def internal_color
      "1;34"
    end

    attr :expressions
  end

  class FunctionCall < SpecializedNode
    def initialize(*children)
      @func = children.first
      @args = children[1, children.size - 1]
    end

    def static_transformed
      @func = @func.static_transformed
      @args = @args.map(&:static_transformed)

      self
    end

    def compute_names_in_scope(parent_names)
      @names_in_scope = parent_names

      @func.compute_names_in_scope(@names_in_scope)
      @args.each do |arg|
        arg.compute_names_in_scope(@names_in_scope)
      end
    end

    def to_s
      args_str = @args.map(&:to_s).join(" ")

      if not args_str.empty?
        args_str = " #{args_str}"
      end

      "(\033[#{self.internal_color}m#{@func}\033[0m#{args_str})"
    end

    def internal_color
      "1;34"
    end

    attr :func, :args
  end

  class If < SpecializedNode
    def initialize(*children)
      @children = children
    end

    def static_transformed
      unless @children.size == 4
        raise ParseException.new(
          "If must have 4 children, got #{@children.size}: " +
            "(#{@children.join(" ")})")
      end

      @cond = @children[1].static_transformed
      @true_expr = @children[2].static_transformed
      @false_expr = @children[3].static_transformed

      self
    end

    def compute_names_in_scope(parent_names)
      @names_in_scope = parent_names

      @cond.compute_names_in_scope(@names_in_scope)
      @true_expr.compute_names_in_scope(@names_in_scope)
      @false_expr.compute_names_in_scope(@names_in_scope)
    end

    def to_s
      "(\033[#{self.internal_color}mif\033[0m " +
        "#{@cond} #{@true_expr} #{@false_expr})"
    end

    def internal_color
      "1;35"
    end

    attr :cond, :true_expr, :false_expr, :children
  end

  class Cond < SpecializedNode
    def initialize(*children)
      @children = children
    end

    def static_transformed
      unless @children.size >= 2
        raise ParseException.new(
          "Cond must have at least two children, got #{@children.size}: " +
            "(#{@children.join(" ")})")
      end

      conditions = @children.drop(1)
      @conditions = conditions.each_with_index.map { |cond, index|
        unless cond.is_a?(NestedNode)
          raise ParseException.new(
            "Condition in Cond expression must be a list, got: #{cond}")
        end

        cond_children = cond.children.reject { |child| child.is_a?(Comment) }

        unless cond_children.size >= 2
          raise ParseException.new(
            "Condition in Cond expression must be have a test " +
              "and at least one expression, got: #{cond_children}")
        end

        test = cond_children[0]
        expressions = cond_children
          .drop(1)
          .map(&:static_transformed)
        if test.is_a?(Var) && test.name == :else
          unless index == conditions.size - 1
            raise ParseException.new(
              "Else condition must be be last condition")
          end

          CondElse.new(expressions)
        else
          CondCondition.new(
            test.static_transformed,
            expressions
          )
        end
      }

      if !@conditions.last.is_a?(CondElse)
        @conditions << CondElse.new([Nil.instance])
      end

      self
    end

    def compute_names_in_scope(parent_names)
      @names_in_scope = parent_names

      @conditions.each do |cond|
        cond.compute_names_in_scope(@names_in_scope)
      end
    end

    attr :conditions
  end

  class CondCondition < SpecializedNode
    def initialize(test, expressions)
      @test = test
      @expressions = expressions
    end

    def compute_names_in_scope(parent_names)
      @names_in_scope = parent_names

      @test.compute_names_in_scope(@names_in_scope)
      @expressions.each do |exp|
        exp.compute_names_in_scope(@names_in_scope)
      end
    end

    attr :test, :expressions
  end

  class CondElse < SpecializedNode
    def initialize(expressions)
      @expressions = expressions
    end

    def compute_names_in_scope(parent_names)
      @names_in_scope = parent_names

      @expressions.each do |exp|
        exp.compute_names_in_scope(@names_in_scope)
      end
    end

    attr :expressions
  end

  class And < SpecializedNode
    def initialize(*children)
      @children = children
    end

    def static_transformed
      unless @children.size >= 2
        raise ParseException.new(
          "and must have at least 2 children, got #{@children.size}: " +
            "(#{@children.join(" ")})")
      end

      @expressions = @children.drop(1).map(&:static_transformed)

      self
    end

    def compute_names_in_scope(parent_names)
      @names_in_scope = parent_names

      @expressions.each do |exp|
        exp.compute_names_in_scope(@names_in_scope)
      end
    end

    attr :expressions
  end

  class Or < SpecializedNode
    def initialize(*children)
      @children = children
    end

    def static_transformed
      unless @children.size >= 2
        raise ParseException.new(
          "or must have at least 2 children, got #{@children.size}: " +
            "(#{@children.join(" ")})")
      end

      @expressions = @children.drop(1).map(&:static_transformed)

      self
    end

    def compute_names_in_scope(parent_names)
      @names_in_scope = parent_names

      @expressions.each do |exp|
        exp.compute_names_in_scope(@names_in_scope)
      end
    end

    attr :expressions
  end

  class Let < SpecializedNode
    include CommonTransformations

    def initialize(let_type, *children)
      @let_type = let_type
      @children = children
    end

    def static_transformed
      unless @children.size >= 3
        raise ParseException.new(
          "Let must have at least three children, got #{@children.size}: " +
            "(#{@children.join(" ")})")
      end

      unless @children[1].is_a?(NestedNode)
        raise ParseException.new(
          "Let bindings must be a list, got: (#{@children[1]})")
      end

      @bindings = @children[1].children
        .reject { |binding| binding.is_a?(Comment) }
        .map { |binding|
          unless binding.is_a?(NestedNode)
            raise ParseException.new(
              "Let binding must be a list, got: (#{binding})")
          end

          children = binding.children.reject { |c| c.is_a?(Comment) }

          unless children.size == 2
            raise ParseException.new(
              "Let binding must have two children, got " +
              "#{children.size}: (#{children.join(" ")})")
          end

          unless children[0].can_be_used_as_binding?
            raise ParseException.new(
              "Let binding must a valid left-hand value, got: " +
              "#{children[0]}")
          end

          name = children[0]
          value = children[1].static_transformed
          LetBinding.new(name, value)
        }

      @expressions = @children.drop(2).map(&:static_transformed)
      @expressions = with_hoisted_definitions(@expressions)

      self
    end

    def compute_names_in_scope(parent_names)
      @names_in_scope = Set.new(parent_names)

      case @let_type
      when :bare then compute_names_in_let_binding_scopes(@names_in_scope)
      when :star then compute_names_in_let_star_binding_scopes(@names_in_scope)
      when :rec  then compute_names_in_letrec_binding_scopes(@names_in_scope)
      end

      binding_names = @bindings
        .flat_map { |binding| names_created_in_binding_lvalue(binding.name) }
      body_def_names = def_names_from_statements(@expressions)
      names_in_body_scope = Set.new(@names_in_scope)
      names_in_body_scope.merge(binding_names)
      names_in_body_scope.merge(body_def_names)

      @expressions.each do |exp|
        exp.compute_names_in_scope(names_in_body_scope)
      end
    end

    def compute_names_in_let_binding_scopes(parent_names)
      # Within the bindings in a "let" block, none of the binding names are
      # visible to other bindings. Only the current bound name is available
      # within the definition of the binding in order to allow for recursion.
      @bindings.each do |binding|
        binding_names = names_created_in_binding_lvalue(binding.name)
        names_in_binding_scope = parent_names + binding_names

        binding.compute_names_in_scope(names_in_binding_scope)
      end
    end

    def compute_names_in_let_star_binding_scopes(parent_names)
      # Within the bindings in a "let*" block, each binding name is visible to
      # its own definition and subsequent definitions.
      names_in_binding_scope = Set.new(parent_names)

      @bindings.each do |binding|
        binding_names = names_created_in_binding_lvalue(binding.name)
        names_in_binding_scope += binding_names

        binding.compute_names_in_scope(names_in_binding_scope)
      end
    end

    def compute_names_in_letrec_binding_scopes(parent_names)
      # Within the bindings in a "letrec" block, all binding names are visible
      # to all bindings, including itself.
      names_in_binding_scope = Set.new(parent_names)

      binding_names = @bindings
        .flat_map { |binding| names_created_in_binding_lvalue(binding.name) }
      names_in_binding_scope.merge(binding_names)

      @bindings.each do |binding|
        binding.compute_names_in_scope(names_in_binding_scope)
      end
    end

    def names_created_in_binding_lvalue(lvalue)
      case lvalue
      when Var then [lvalue.name]
      when DottedList, NestedNode
        lvalue
          .children
          .flat_map { |child| names_created_in_binding_lvalue(child) }
      end
    end

    attr :let_type, :bindings, :expressions
  end

  class LetBinding < SpecializedNode
    def initialize(name, value)
      @name = name
      @value = value
    end

    def compute_names_in_scope(parent_names)
      @names_in_scope = parent_names

      @name.compute_names_in_scope(@names_in_scope)
      @value.compute_names_in_scope(@names_in_scope)
    end

    attr :name, :value
  end

  class ASTTransform < Parslet::Transform
    rule(var: simple(:name))    { Var.new(name.to_s.intern) }
    rule(hex: simple(:value))   { IntVal.new(value.to_s.to_i(16)) }
    rule(int: simple(:value))   { IntVal.new(value.to_i) }
    rule(float: simple(:value)) { FloatVal.new(value.to_f) }
    rule(true: simple(:x))      { TrueVal.instance }
    rule(false: simple(:x))     { FalseVal.instance }

    rule(list: sequence(:x))    { NestedNode.new(*x) }
    rule(dotlist: sequence(:x)) { DottedList.new(*x) }

    rule(quoted: simple(:q))    { Quoted.new(q) }
    rule(string: simple(:s))    { String.new(s) }

    rule(comment: simple(:c))   { Comment.new(c) }
    rule(exprs: sequence(:x))   { GarlicModule.new(*x) }
  end

  def AST.construct_from_parse_tree(tree, filename, included_modules)
    ast = ASTTransform.new.apply(tree)
    ast.filename = filename
    ast = ast.static_transformed(included_modules)
  end
end

## NATIVE CODE GENERATION ######################################################

module AST
  ARG_REGS = [
    "rdi",
    "rsi",
    "rdx",
    "rcx",
    "r8",
    "r9"
  ]

  class ProgramModule
    class CompileException < Exception; end

    def codegen(all_modules)
      case module_type
      when MODULE_TYPE_GARLIC
        ast.codegen(filename, module_name, is_main, all_modules)
      when MODULE_TYPE_C
        ast.codegen(filename, module_name, all_modules)
      else
        raise CompileException.new(
          "unknown module type: #{module_type} for filename: #{filename}")
      end
    end
  end

  class GarlicModule
    def codegen(filename, symbol_prefix, is_main, all_modules)
      vm = VM::VM.new(
        filename,
        symbol_prefix,
        is_main,
        @recursive_requires,
        @module_exports
      )

      compute_external_symbols_in_namespace(
        module_requires,
        all_modules
      )

      @statements.each do |statement|
        statement.codegen(vm, self, all_modules)
      end

      vm.commit
    end
  end

  class CModule
    def codegen(filename, module_name, all_modules)
      @statements = []

      wrapper_prefix = VM::VM.symbol_prefix_from_module_name(module_name)
      wrapper_filename = VM::VM.output_filename(module_name)
      module_base_name = File.basename(module_name)

      main_name = "init_#{wrapper_prefix}"
      filename_relative = Pathname.new(filename).relative_path_from(Dir.pwd)

      asm("# " + ("-" * 77))
      asm "# Generated assembly wrapper around #{filename_relative}"
      asm("# " + ("-" * 77))
      asm ""

      asm "# MACROS: needed for cross-platform compatibility"

      asm "#if defined(__WIN32__) || defined(__APPLE__)"
      asm "# define cdecl(s) _##s"
      asm "#else"
      asm "# define cdecl(s) s"
      asm "#endif"

      asm ""
      asm "# The remaining macros make it easier to specify Position"
      asm "# Independent Code (PIC)."
      asm ""

      asm "# define movlabelreg(src, dst) movq    src##\@GOTPCREL(%rip), dst"

      asm ""

      asm "# define movlabelvalreg(src, dst) \\"
      asm "    movq    src##\@GOTPCREL(%rip), %r8 ;\\"
      asm "    movq    (%r8), dst"

      asm ""

      asm "# define movreglabel(src, dst) \\"
      asm "    movq    dst##\@GOTPCREL(%rip), %r8 ;\\"
      asm "    movq    src, (%r8)"

      asm ""
      asm "        .global cdecl(#{main_name})"
      asm ""
      asm "        .text"
      asm "cdecl(#{main_name}):"
      asm "        movlabelvalreg(#{wrapper_prefix}_is_initialized, %rax)"
      asm "        cmpq    $0, %rax"
      asm "        je      #{main_name}_do_init"
      asm "        ret"
      asm "#{main_name}_do_init:"
      asm "        movreglabel($1, #{wrapper_prefix}_is_initialized)"
      asm "        sub     $8, %rsp"
      asm "        call    cdecl(new_root_frame)"
      asm "        add     $8, %rsp"
      asm "        movreglabel(%rax, #{wrapper_prefix}_root_frame)"
      asm ""

      asm "        movlabelreg(cdecl(#{module_base_name}_exports), %rax)"
      @c_exports.each_with_index do |exp, i|
        asm "        push    %rax"

        # make a lambda using the root frame as the parent frame
        asm "        movlabelreg(#{wrapper_prefix}_root_frame, %rdi)"
        asm "        movq    (%rdi), %rdi"
        asm "        movlabelreg(#{wrapper_prefix}_native_fn_#{i}, %rsi)"
        asm "        call    cdecl(make_fn)"

        asm "        movlabelreg(#{wrapper_prefix}_root_frame, %rdi)"
        asm "        movq    (%rdi), %rdi" # (1) root frame
        asm "        movq    (%rsp), %rsi" # (2) name of...
        asm "        movq    (%rsi), %rsi" #     ...native function
        asm "        movq    %rax, %rdx"   # (3) lambda
        asm "        call    cdecl(add_to_frame)"

        asm "        pop     %rax"
        asm "        add     $24, %rax"
      end

      asm "        ret"
      asm ""

      @c_exports.each_with_index do |exp, i|
        asm "#{wrapper_prefix}_native_fn_#{i}:"

        if exp.is_vararg
          asm "        movq    $#{exp.arity}, %rdi"
          asm "        call    cdecl(gather_varargs)"

          # When the function was initially called, there was an extra space
          # left on the stack specifically to store the gathered extra
          # arguments. This is needed in the case that there were no extra
          # arguments, so essentially, a new argument needs to be added to the
          # stack. Thus, we've guaranteed we're not overwriting anything on
          # the stack that we need to preserve.
          last_arg_offset = exp.arity * 8 + 16
          asm "        movq    %rax, #{last_arg_offset}(%rsp)"
        end

        num_args =
          if exp.is_vararg
            exp.arity + 1 # required arguments + "rest" list
          else
            exp.arity
          end

        spill_onto_stack = num_args > ARG_REGS.size
        num_args_in_reg = [num_args, ARG_REGS.size].min

        (0...num_args_in_reg)
          .map {|i| i * 8 + 16}
          .zip(ARG_REGS)
          .each do |offset, reg|
            asm "        movq    #{offset}(%rsp), %#{reg}"
          end

        if spill_onto_stack
          # %r12 is callee saved, so we'll be able to grab the current return
          # address again after calling the native function
          asm "        movq    8(%rsp), %r12"
          asm "        add     $56, %rsp"
        end

        # remove the unnecessary stack frame that was allocated
        asm "        add     $8, %rsp"

        asm "        movlabelreg(cdecl(#{module_base_name}_exports), %rax)"
        asm "        movq    #{i * 24 + 8}(%rax), %rax"

        if spill_onto_stack
          asm "        call    *%rax"

          asm "        sub     $48, %rsp"
          asm "        push    %r12"
          asm "        ret"
        else
          asm "        jmp     *%rax"
        end
      end
      asm ""

      getter_name = VM::VM.getter_name_for_module(module_base_name)

      asm "        .global cdecl(#{getter_name})"
      asm "cdecl(#{getter_name}):"
      asm "        sub     $8, %rsp"

      asm "        mov     %rdi, %rsi"
      asm "        movlabelreg(#{wrapper_prefix}_root_frame, %rdi)"
      asm "        mov     (%rdi), %rdi"

      asm "        call    cdecl(find_in_frame)"
      asm "        add     $8, %rsp"
      asm "        ret"
      asm ""

      asm "        .data"
      asm ""

      asm "#{wrapper_prefix}_root_frame:"
      asm "        .quad 0"
      asm "#{wrapper_prefix}_is_initialized:"
      asm "        .quad 0"

      File.open(wrapper_filename, 'w') do |f|
        f.puts(@statements.join("\n"))
      end

      source_build_filename = VM::VM.output_filename(module_name, 'c')
      FileUtils.copy_file(filename, source_build_filename)
    end

    def asm(statement)
      @statements << statement
    end
  end

  class Comment < Node
    def codegen(vm, program, all_modules)
      # do nothing!
    end
  end

  class QuotedAtom < Node
    def codegen(vm, program, all_modules)
      name = vm.addquotedatom(@name)
      vm.movlabelreg "#{name}_name", "%rdi"
      vm.with_aligned_stack do
        vm.call "get_atom"
      end
    end
  end

  class QuotedList < Node
    def codegen(vm, program, all_modules)
      vm.asm "        mov     $0, %rsi" if !is_nil_terminated

      filtered_children = @children.reject { |arg| arg.is_a?(Comment) }
      filtered_children.reverse.each_with_index do |child, index|
        if !is_nil_terminated or index > 0
          vm.push("%rsi")
          child.codegen(vm, program, all_modules)
          vm.pop("%rsi")

          vm.asm "        mov     %rax, %rdi"
          vm.with_aligned_stack do
            vm.call "garlic_make_cons"
          end
        else
          child.codegen(vm, program, all_modules)
        end

        unless index == filtered_children.size - 1
          vm.asm "        mov     %rax, %rsi"
        end
      end
    end
  end

  class String < Node
    def codegen(vm, program, all_modules)
      name = vm.addstring(@contents)
      vm.movlabelreg "#{name}_contents", "%rdi"

      vm.with_aligned_stack do
        vm.call "garlic_wrap_string"
      end
    end
  end

  class Nil < Node
    def codegen(vm, program, all_modules)
      vm.asm "        mov     $0, %rax"
    end
  end

  class Var < Node
    def codegen(vm, program, all_modules)
      if name.to_s.include?(":")
        module_prefix, internal_name = name.to_s.split(":")

        require_spec = program
          .module_requires
          .find { |req|
            req.basename == module_prefix ||
              req.nickname.to_s == module_prefix
          }

        if require_spec.nil?
          raise ProgramModule::CompileException.new(
            "unable to find required module: #{module_prefix}")
        elsif require_spec.basename == module_prefix and require_spec.nickname
          raise ProgramModule::CompileException.new(
            "renamed module #{require_spec.basename} " +
              "not referred by nickname #{require_spec.nickname}")
        else
          actual_module_prefix = require_spec.basename
        end

        child_program = all_modules
          .find { |req|
            req.module_name == require_spec.absolute_path
          }

        if child_program.nil?
          # This can't happen since the requires correspond one-to-one with the
          # child programs
          raise ProgramModule::CompileException.new(
            "internal error: can't find required child module " +
              "#{require_spec.absolute_path}")
        end

        unless child_program.ast.module_exports.include?(internal_name.intern)
          raise ProgramModule::CompileException.new(
            "module \"#{module_prefix}\" does not export symbol " +
              "\"#{internal_name}\"")
        end

        load_external_symbol(vm, internal_name, actual_module_prefix)
      else
        if @names_in_scope.include?(name)
          varname = vm.addvarname(self)

          vm.argframe
          vm.movlabelreg varname, "%rsi"
          vm.with_aligned_stack do
            vm.call "find_in_frame"
          end
        elsif program.external_symbols_in_namespace.has_key?(name)
          module_prefix = File.basename(
            program
              .external_symbols_in_namespace[name]
              .module_name
          )

          load_external_symbol(vm, name, module_prefix)
        else
          raise ProgramModule::CompileException.new(
            "undefined variable referenced: #{name}")
        end
      end
    end

    def load_external_symbol(vm, symbol_name, module_prefix)
      varname = vm.addvarname(Var.new(symbol_name))
      vm.movlabelreg varname, "%rdi"

      vm.with_aligned_stack do
        getter_name = VM::VM.getter_name_for_module(module_prefix)
        vm.call getter_name
      end
    end
  end

  class IntVal < Node
    def codegen(vm, program, all_modules)
      # TODO: large numbers
      val = (@value << 1) | 0x1
      vm.asm "        mov     $#{val}, %rax"
    end
  end

  class FloatVal < Node
    def codegen(vm, program, all_modules)
      vm.with_aligned_stack do
        # We can't load a literal into %xmm0. Another option is to store the
        # constant in the .data section, then load it. However, using the
        # standard movlabelreg macro doesn't seem to be working without
        # requiring some dereferencing, meaning we need two instructions to
        # load the value anyway.
        #
        # In the future, if this is a bottleneck, it can be figured out how to
        # load it in one instruction.

        bitstring = [@value].pack('G').unpack('H16').first
        vm.asm "        mov     $0x#{bitstring}, %rax"
        vm.asm "        movq    %rax, %xmm0"
        vm.call "double_to_garlicval"
      end
    end
  end

  class TrueVal < Node
    def codegen(vm, program, all_modules)
      vm.asm "        mov     $2, %rax"
    end
  end

  class FalseVal < Node
    def codegen(vm, program, all_modules)
      vm.asm "        mov     $4, %rax"
    end
  end

  class Definition < SpecializedNode
    def codegen(vm, program, all_modules)
      varname = vm.addvarname(@name)
      @value.codegen(vm, program, all_modules)
      # now the value is in %rax
      vm.argframe
      vm.movlabelreg varname, "%rsi"
      vm.asm "        mov     %rax, %rdx"
      vm.with_aligned_stack do
        vm.call "add_to_frame"
      end
    end
  end

  class Lambda < SpecializedNode
    def codegen(vm, program, all_modules)
      # Generating code for a lambda is a bit involved, so it's good to list
      # out the steps.
      #
      # 1. Immediately jmp ahead to after the generated code that will be
      #    called when the lambda is invoked. No need to call it now!
      #
      # 2. For each argument on the stack, generate code to add it to the
      #    current frame. Note that when the lambda is being invoked, the
      #    garlic_fncall function has already created a new frame using the
      #    lambda's parent frame, so we'll be using that frame.
      #
      # 3. Generate code to run the lambda body.
      #
      # 4. Generate code to return from the function.
      #
      # 5. Now, we're at the point we jmp'ed to earlier. This code *will* be
      #    executed when the lambda is defined. Here, we'll generate code to
      #    create a wrapped lambda using the make_fn function. The result is
      #    stored in %rax, and we're done.
      #
      # One thing to watch out for: when garlic_fncall invokes the lambda body,
      # a new frame has already been created and pushed onto the stack. Thus,
      # we have to reset the offset on the stack to the current frame in our
      # VM.

      name = vm.genname('fn')
      endname = "#{name}_end"

      vm.asm "        jmp     #{endname}"
      vm.asm "#{name}:"

      # lambda body

      vm.fnstart

      if is_vararg
        # Start by the gathering up the last argument. The steps are as
        # follows:
        #
        # 1. Take the number of arguments passed to this lambda and subtract
        #    the number of non-vararg arguments.
        #
        # 2. Use gather_varargs to put all the varargs (which are at the "top"
        #    of the stack after accounting for return pointers, etc.) into
        #    %rax.
        #
        # 3. Add the resulting list to the frame.
        #
        # 4. Restore the number of arguments in %rsi by adding back in the
        #    number of non-vararg arguments (this has to be done a little later
        #    actually, because we still need the number gathered arguments).
        rest_varname = vm.addvarname(rest_param)

        #vm.asm "        movq    %rsi, %rdi"
        vm.asm "        movq    $#{params.size}, %rdi"

        vm.with_aligned_stack do
          vm.call "gather_varargs"
        end

        vm.push("%rsi")

        vm.argframe
        vm.movlabelreg rest_varname, "%rsi"
        vm.asm "        mov     %rax, %rdx"
        vm.with_aligned_stack do
          vm.call "add_to_frame"
        end

        vm.pop("%rsi")
      end

      # Now set up the pointer to the first non-vararg argument:
      vm.asm "        mov     %rsp, %r8"
      vm.asm "        add     $16, %r8"

      params.each do |param|
        varname = vm.addvarname(param)

        vm.argframe
        vm.movlabelreg varname, "%rsi"
        vm.asm "        mov     (%r8), %rdx"
        vm.push("%r8")
        vm.with_aligned_stack do
          vm.call "add_to_frame"
        end
        vm.pop("%r8")
        vm.asm "        add     $8, %r8"
      end

      body_statements.each do |statement|
        statement.codegen(vm, program, all_modules)
      end

      vm.fnend

      vm.asm "        ret"
      vm.asm "#{endname}:"

      # generate the actual lambda

      vm.argframe
      vm.movlabelreg name, "%rsi"
      vm.with_aligned_stack do
        vm.call "make_fn"
      end
    end
  end

  class Begin < SpecializedNode
    def codegen(vm, program, all_modules)
      @expressions.each do |expr|
        expr.codegen(vm, program, all_modules)
      end
    end
  end

  class FunctionCall < SpecializedNode
    def codegen(vm, program, all_modules)
      # First, generate code for each argument and push it onto the stack in
      # reverse order. This is because arguments that don't fit in the
      # registers are pushed onto the stack from right to left. Additionally,
      # after all the arguments have been pushed onto the stack, the ones that
      # fit in the registers can be popped off one by one before calling the
      # function.
      #
      # Certain arguments should be ignored completely, namely comments, since
      # they do not produce any values in %rax that need to be pushed onto the
      # stack. They should not contribute to the number of arguments either.

      filtered_args = @args.reject { |arg| arg.is_a?(Comment) }

      # We don't actually know what function is being called. If it's a
      # variadic garlic function, then the extra arguments will be gathered up
      # and added to the new frame that will be created for the function
      # invocation.
      #
      # However, if it's a variadic C function, then the gathered arguments
      # need to be added back to the stack, so we should leave some space for
      # that. This space needs to exist even if there are no extra arguments.

      # Make sure to account for the extra space left on the stack above when
      # aligning the stack.
      vm.with_aligned_stack(filtered_args.size + 1) do
        # Extra space on the stack.
        vm.push

        filtered_args.reverse.each do |arg|
          arg.codegen(vm, program, all_modules)
          vm.push("%rax")
        end

        # Evaluate the expression in order to get the wrapped function pointer.
        @func.codegen(vm, program, all_modules)

        vm.asm "        mov     %rax, %rdi"
        vm.asm "        mov     $#{filtered_args.size}, %rsi"
        vm.call "garlic_fncall"

        # Make sure to pop off the extra space left on the stack.
        vm.popn(filtered_args.size + 1)
      end
    end
  end

  class If < SpecializedNode
    def codegen(vm, program, all_modules)
      label = vm.genname('if')

      @cond.codegen(vm, program, all_modules)

      vm.asm "        cmp     $4, %rax"
      vm.asm "        je      #{label}_false"

      @true_expr.codegen(vm, program, all_modules)

      vm.asm "        jmp     #{label}_end"
      vm.asm "#{label}_false:"

      @false_expr.codegen(vm, program, all_modules)

      vm.asm "#{label}_end:"
    end
  end

  class Cond < SpecializedNode
    def codegen(vm, program, all_modules)
      label = vm.genname('cond')

      condition_labels = @conditions.each_with_index.map { |cond, index|
        if cond.is_a?(CondCondition)
          if index.zero?
            "#{label}_begin"
          else
            "#{label}_#{index}"
          end
        elsif cond.is_a?(CondElse)
          "#{label}_else"
        end
      }

      condition_labels.push("#{label}_end")

      @conditions.each_with_index do |cond, index|
        vm.asm "#{condition_labels[index]}:"

        if cond.is_a?(CondCondition)
          cond.test.codegen(vm, program, all_modules)

          vm.asm "        cmp     $4, %rax"
          vm.asm "        je      #{condition_labels[index + 1]}"

          cond.expressions.each do |exp|
            exp.codegen(vm, program, all_modules)
          end

          if index != @conditions.size - 1
            vm.asm "        jmp     #{condition_labels.last}"
          end
        elsif cond.is_a?(CondElse)
          cond.expressions.each do |exp|
            exp.codegen(vm, program, all_modules)
          end
        end
      end

      vm.asm "#{condition_labels.last}:"
    end
  end

  class And < SpecializedNode
    def codegen(vm, program, all_modules)
      end_label_name = vm.genname('and')

      @expressions.each do |exp|
        exp.codegen(vm, program, all_modules)
        vm.jfalsey("#{end_label_name}_false")
      end

      vm.asm "        mov     $2, %rax"
      vm.asm "        jmp     #{end_label_name}"

      vm.asm "#{end_label_name}_false:"
      vm.asm "        mov     $4, %rax"

      vm.asm "#{end_label_name}:"
    end
  end

  class Or < SpecializedNode
    def codegen(vm, program, all_modules)
      end_label_name = vm.genname('or')

      @expressions.each_with_index do |exp, i|
        vm.asm "#{end_label_name}_#{i}_false:"
        exp.codegen(vm, program, all_modules)
        vm.jfalsey("#{end_label_name}_#{i + 1}_false")
        vm.asm "        mov     $2, %rax"
        vm.asm "        jmp     #{end_label_name}"
      end

      vm.asm "#{end_label_name}_#{@expressions.size}_false:"
      vm.asm "        mov     $4, %rax"
      vm.asm "#{end_label_name}:"
    end
  end

  class Let < SpecializedNode
    def codegen(vm, program, all_modules)
      vm.argframe
      vm.with_aligned_stack do
        vm.call "new_frame_with_parent"
      end

      # Note that we *won't* be pushing a return address. with_aligned_stack
      # assumes that we will, so after that fictitious return address is
      # pushed, we want to end up back at the same point we are at now.
      vm.with_aligned_stack(-1) do
        vm.new_empty_frame
        vm.push("%rax")

        # It's possible to allow for let and let* semantics by varying the
        # way the bindings are actually evaluated. However, static analysis is
        # sufficient to enforce the correct semantics, so during code
        # generation, we can use the most efficient code, which is to just
        # evaluate the bindings in order and add them to new frame.
        bindings.each do |binding|
          # Generate the value that will be assigned to the left-hand side name
          # or names.
          binding.value.codegen(vm, program, all_modules)
          codegen_single_non_destructuring_assignment(vm, binding.name, "rax")
        end

        expressions.each do |expression|
          expression.codegen(vm, program, all_modules)
        end

        vm.pop
        vm.remframe
      end
    end

    def codegen_single_non_destructuring_assignment(vm, lvalue, source)
      case lvalue
      when Var
        varname = vm.addvarname(lvalue)

        vm.asm "        mov     %#{source}, %rdx"
        vm.movlabelreg varname, "%rsi"

        vm.argframe
        vm.with_aligned_stack do
          vm.call "add_to_frame"
        end
      when DottedList
        if source != "rax"
          vm.asm "        mov     %#{source}, %rax"
        end

        codegen_assignment_to_dotted_list(vm, lvalue)
      when NestedNode
        if source != "rax"
          vm.asm "        mov     %#{source}, %rax"
        end

        codegen_assignment_to_list(vm, lvalue)
      end
    end

    def codegen_single_destructuring_assignment(vm, lvalue, source)
      # Check that the rvalue is a cons cell. This is instead of segfaulting
      # when trying to unpack the cell.
      vm.asm "        mov     %#{source}, %rdi"
      vm.call "check_destructuring_assignment"

      case lvalue
      when Var
        varname = vm.addvarname(lvalue)

        vm.asm "        mov     8(%#{source}), %rdx"
        vm.asm "        mov     16(%#{source}), %#{source}"

        vm.movlabelreg varname, "%rsi"

        vm.argframe
        vm.with_aligned_stack do
          vm.call "add_to_frame"
        end
      when DottedList
        vm.asm "        mov     8(%#{source}), %rax"
        vm.asm "        mov     16(%#{source}), %#{source}"
        vm.push("%#{source}")
        codegen_assignment_to_dotted_list(vm, lvalue)
        vm.pop("%#{source}")
      when NestedNode
        vm.asm "        mov     8(%#{source}), %rax"
        vm.asm "        mov     16(%#{source}), %#{source}"
        vm.push("%#{source}")
        codegen_assignment_to_list(vm, lvalue)
        vm.pop("%#{source}")
      end
    end

    def codegen_assignment_to_dotted_list(vm, lvalue)
      # %r12 is callee saved, so the call to "add_to_frame" won't overwrite
      # the value we want to assign to the bindings.
      vm.asm("        mov     %rax, %r12")

      lvalue.children.each.with_index do |name, i|
        if i < lvalue.children.size - 1
          # When the left-hand side is a dotted list with N entries, the first
          # N - 1 entries are pulled off the right-hand side and assigned to
          # those first variables...
          codegen_single_destructuring_assignment(vm, name, "r12")
        else
          # ...and the last entry is assigned the rest of the list.
          codegen_single_non_destructuring_assignment(vm, name, "r12")
        end
      end
    end

    def codegen_assignment_to_list(vm, lvalue)
      # %r12 is callee saved, so the call to "add_to_frame" won't overwrite
      # the value we want to assign to the bindings.
      vm.asm("        mov     %rax, %r12")

      lvalue.children.each do |name|
        # When the left-hand side is a nil-terminated list with N entries, the
        # first N entries are pulled off the right-hand side and assigned to
        # those variables.
        codegen_single_destructuring_assignment(vm, name, "r12")
      end

      # The very last entry in the list should be a `nil`. If any and all
      # remaining entries are supposed to be put into a "rest" variable, a
      # dotted list assignment should be used.
      vm.asm "        mov     %r12, %rdi"
      vm.call "check_destructuring_terminated_in_nil"
    end
  end
end

module VM
  class VM
    def initialize(filename,
                   module_name,
                   is_main,
                   module_requires,
                   module_exports)
      # VM properties
      @filename = filename
      @module_name = module_name
      @symbol_prefix = VM.symbol_prefix_from_module_name(module_name)
      @is_main = is_main
      @module_requires = module_requires
      @module_exports = module_exports

      @statements = []

      # names
      @varnames = {}
      @quotedatoms = {}
      @stringnames = {}

      @frame_offsets = []
      new_empty_frame

      # counters
      @current_name_index_by_type = Hash.new(0)

      prologue
    end

    def self.getter_name_for_module(module_name)
      symbol_prefix = symbol_prefix_from_module_name(module_name)
      "module_get_#{symbol_prefix}"
    end

    def prologue
      main_name =
        if @is_main
          "main"
        else
          "init_#{@symbol_prefix}"
        end
      filename_relative = Pathname.new(@filename).relative_path_from(Dir.pwd)

      asm("# " + ("-" * 77))
      asm "# Compiled assembly from #{filename_relative}"
      asm("# " + ("-" * 77))
      asm ""

      asm "# MACROS: needed for cross-platform compatibility"

      asm "#if defined(__WIN32__) || defined(__APPLE__)"
      asm "# define cdecl(s) _##s"
      asm "#else"
      asm "# define cdecl(s) s"
      asm "#endif"

      asm ""
      asm "# The remaining macros make it easier to specify Position"
      asm "# Independent Code (PIC)."
      asm ""

      asm "# define movlabelreg(src, dst) movq    src##\@GOTPCREL(%rip), dst"

      asm ""

      asm "# define movlabelvalreg(src, dst) \\"
      asm "    movq    src##\@GOTPCREL(%rip), %r8 ;\\"
      asm "    movq    (%r8), dst"

      asm ""

      asm "# define movreglabel(src, dst) \\"
      asm "    movq    dst##\@GOTPCREL(%rip), %r8 ;\\"
      asm "    movq    src, (%r8)"

      asm ""
      asm "        .global cdecl(#{main_name})"
      asm ""
      asm "        .text"
      asm "cdecl(#{main_name}):"
      asm "        movlabelvalreg(#{@symbol_prefix}_is_initialized, %rax)"
      asm "        cmpq    $0, %rax"
      asm "        je      #{main_name}_do_init"
      asm "        ret"
      asm "#{main_name}_do_init:"
      asm "        movreglabel($1, #{@symbol_prefix}_is_initialized)"
      if @is_main
        # In the main function, the arguments are "argc" and "argv". These need
        # to be saved so they can be added to the root frame after the root
        # frame has been created.
        push "%rdi"
        push "%rsi"
      end
      push
      asm "        call    #{@symbol_prefix}_create_atoms"
      call "new_root_frame"
      asm "        movreglabel(%rax, #{@symbol_prefix}_root_frame)"
      pop
      if @is_main
        # The first and second arguments were saved, but they will become the
        # second and third arguments respectively to the "create_argv"
        # function. The first argument will be the root frame itself.
        pop "%rdx"
        pop "%rsi"
      end
      push("%rax")

      if @is_main
        asm "        mov     %rax, %rdi"
        call "create_argv"
      end

      asm ""
      @module_requires.each do |mod|
        name = mod.module_name
        call "init_#{VM.symbol_prefix_from_module_name(name)}"
      end
    end

    def epilogue
      asm ""
      asm "        add     $8, %rsp"
      asm "        mov     $0, %rax"
      asm "        ret"
      asm ""

      asm "#{@symbol_prefix}_create_atoms:"
      asm "        sub     $8, %rsp"

      call "init_atom_db"

      @quotedatoms.each do |name, label|
        movlabelreg "#{label}_name", "%rdi"
        call "create_atom"
      end
      asm ""

      asm "        add     $8, %rsp"
      asm "        ret"
      asm ""

      module_name = File.basename(@module_name)
      getter_name = VM.getter_name_for_module(module_name)

      asm "        .global cdecl(#{getter_name})"
      asm "cdecl(#{getter_name}):"
      asm "        sub     $8, %rsp"

      asm "        mov     %rdi, %rsi"
      asm "        movlabelreg(#{@symbol_prefix}_root_frame, %rdi)"
      asm "        mov     (%rdi), %rdi"

      call "find_in_frame"
      asm "        add     $8, %rsp"
      asm "        ret"
      asm ""

      asm "        .data"
      asm ""

      @varnames.each do |name, label|
        asm "#{label}:"
        asm "        .asciz  \"#{name}\""
      end

      asm "        ret"
      asm ""

      @quotedatoms.each do |name, label|
        asm "#{label}_name:"
        asm "        .asciz  \"#{name}\""
      end
      asm ""

      @stringnames.each do |contents, label|
        asm "#{label}_contents:"
        asm "        .asciz  \"#{contents}\""
      end

      asm ""
      asm "#{@symbol_prefix}_root_frame:"
      asm "        .quad 0"
      asm "#{@symbol_prefix}_is_initialized:"
      asm "        .quad 0"
    end

    def commit
      epilogue

      output_filename = VM.output_filename(@module_name)
      File.open(output_filename, 'w') do |f|
        f.puts(@statements.join("\n"))
      end
    end

    def addvarname(name)
      name_str = name.name.to_s

      if @varnames.has_key?(name_str)
        @varnames[name_str]
      else
        label = "#{@symbol_prefix}_var_#{Digest::MD5.hexdigest(name_str)}"
        @varnames[name_str] = label
        label
      end
    end

    def addquotedatom(name)
      name_str = name.to_s

      if @quotedatoms.has_key?(name_str)
        @quotedatoms[name_str]
      else
        label = "#{@symbol_prefix}_atom_#{Digest::MD5.hexdigest(name_str)}"
        @quotedatoms[name_str] = label
        label
      end
    end

    def addstring(contents)
      # Make sure to write out explicit newline separators, instead of
      # including them verbatim in the assembly code.
      contents_str = contents.to_s.gsub(/(\r\n|\n|\r)+/, '\n')

      if @stringnames.has_key?(contents_str)
        @stringnames[contents_str]
      else
        label =
          "#{@symbol_prefix}_string_#{Digest::MD5.hexdigest(contents_str)}"
        @stringnames[contents_str] = label
        label
      end
    end

    def genname(type)
      name = "#{@symbol_prefix}_#{type}_#{@current_name_index_by_type[type]}"
      @current_name_index_by_type[type] += 1
      name
    end

    def jfalsey(label)
      asm "        cmp     $4, %rax"
      asm "        je      #{label}"
      asm "        cmp     $0, %rax"
      asm "        je      #{label}"
    end

    def push(reg = nil)
      if reg.nil?
        asm "        sub     $8, %rsp"
      else
        asm "        push    #{reg}"
      end

      last = @frame_offsets.pop
      @frame_offsets.push(last + 8)
    end

    def pop(reg = nil)
      if reg.nil?
        asm "        add     $8, %rsp"
      else
        asm "        pop     #{reg}"
      end

      last = @frame_offsets.pop
      @frame_offsets.push(last - 8)
    end

    def popn(n)
      asm "        add     $#{n * 8}, %rsp"

      last = @frame_offsets.pop
      @frame_offsets.push(last - n * 8)
    end

    def argframe
      offset = lstoffset - 8
      if offset > 0
        asm "        mov     #{offset}(%rsp), %rdi"
      else
        asm "        mov     (%rsp), %rdi"
      end
    end

    def new_empty_frame
      @frame_offsets.push(0)
    end

    def remframe
      @frame_offsets.pop
    end

    def fnstart
      # stdlib has done the work of creating a new frame for this function
      # and pushed it onto the stack.
      @frame_offsets.push(8)
    end

    def fnend
      pop # remove the current frame pointer
      remframe
    end

    def lstoffset
      @frame_offsets.last
    end

    def call(fnname)
      asm "        call    cdecl(#{fnname})"
    end

    def movlabelreg(src, dst)
      asm "        movlabelreg(#{src}, #{dst})"
    end

    def with_aligned_stack(num_args_to_push = 0)
      # When a function call is made, the stack needs to be aligned to a 16-
      # byte boundary. There's a catch, in that the call needs to be made with
      # the stack alignment offset by 8 bytes, because the return address will
      # be pushed to the top of the stack. The stack has to be aligned *after*
      # the return address is pushed!

      # Another issue, when calling a "user-defined" function, is that we want
      # the arguments to be as close to the top of the stack as possible, so
      # that the garlic_fncall function (and other functions it calls into)
      # know where its arguments are, regardless of how the stack had to be
      # aligned.  So, we'll align the stack *before* pushing the arguments.
      # Whether or not we need to align depends on the current stack alignment
      # and the number arguments we'll be pushing.
      is_stack_aligned = (lstoffset / 8) % 2 == 1
      has_even_num_args = num_args_to_push % 2 == 0

      should_not_align_stack =
        ( is_stack_aligned &&  has_even_num_args) ||
        (!is_stack_aligned && !has_even_num_args)
      should_align_stack = !should_not_align_stack

      if should_align_stack
        asm("# aligning stack")
        push
      end

      yield

      if should_align_stack
        pop
        asm("# unaligning stack")
      end
    end

    def asm(statement)
      @statements << statement
    end

    private

    def self.normalized_name_for_name(name)
      name = name.to_s
      normalized_name = name.gsub(/[^a-z_]+/i, '_')
      normalized_name = 'empty' if normalized_name.empty?
      normalized_name
    end

    def self.symbol_prefix_from_module_name(module_name)
      "m_#{Digest::MD5.hexdigest(module_name.to_s)}"
    end

    def self.output_filename(module_name, extension = 'S')
      "build/#{self.symbol_prefix_from_module_name(module_name)}.#{extension}"
    end

  end
end

## FILE PROCESSING #############################################################

BUILD_DIR = 'build'

def read_into_tmp_file
  file = Tempfile.new("garlic")
  contents = STDIN.read
  file.write(contents)
  file.close

  file
end

def create_fresh_build_env(out_exe_name, build_dir_name)
  if File.file?(out_exe_name)
    FileUtils.rm(out_exe_name)
  end

  if File.directory?(build_dir_name)
    FileUtils.rm_r(build_dir_name)
  end

  FileUtils.mkdir_p(build_dir_name)
end

def compile_file(filename)
  module_tree = gather_asts(filename, 'main', true)

  # Linearize the dependency DAG
  all_modules = []
  tree_queue = [module_tree]
  until tree_queue.empty?
    tree = tree_queue.shift
    tree_queue += tree.child_modules
    all_modules << tree
  end

  all_modules.each { |mod| mod.codegen(all_modules) }
end

def gather_asts(filename,
                module_name,
                is_main,
                module_type = AST::ProgramModule::MODULE_TYPE_GARLIC,
                gathered = nil)
  gathered ||= Set.new
  gathered << filename

  case module_type
  when AST::ProgramModule::MODULE_TYPE_GARLIC
    file = File.read(filename)
    parsed = GarlicParser.new.parse(file)
    ast = AST.construct_from_parse_tree(parsed, filename, gathered)

    child_modules = ast.recursive_requires

    AST::ProgramModule.new(
      filename,
      module_name,
      is_main,
      module_type,
      ast,
      child_modules
    )
  when AST::ProgramModule::MODULE_TYPE_C
    ast = AST::CModule.new(filename, module_name)

    AST::ProgramModule.new(
      filename,
      module_name,
      is_main,
      module_type,
      ast,
      []
    )
  else
    raise ParseException.new(
      "unrecognized module type: #{module_type} for filename: #{filename}")
  end
end

def run_gcc(out_filename, compiler_opts)
  # NOTE: compiler_opts is an array of strings, which add to the list of
  # compiler options separated by spaces. However, if the user were to include
  # an option that was quoted and contained spaces, it would be improperly
  # handled:
  #
  #   ./garlic input-file.scm -- a "b c" d
  #
  # would result in
  #
  #   gcc --hardcoded-args a b c d -o output
  #
  # Notice that "b c" is not preserved as a single argument. For now, we can
  # accept this as a known limitation because this case should be rare. It can
  # be revisted if necessary.
  base = compiler_dir
  system(
    "gcc -g -I #{base}/stdlib-includes " +
      "build/* #{base}/runtime.c #{base}/runtime.S #{base}/hashmap.c " +
      "#{compiler_opts.join(" ")} " +
      "-o #{out_filename}"
  )
end

def compiler_dir
  File.dirname(File.absolute_path(__FILE__))
end

def includes_dir
  "#{compiler_dir}/stdlib-includes"
end

def stdlib_filename
  "#{includes_dir}/stdlib.scm"
end

def absolute_path_for_module(relative_path, basedir = nil)
  File.absolute_path(relative_path, basedir)
end

## MAIN ########################################################################

VERSION = '0.1.0'

doc = <<USAGESTR
USAGE: #{__FILE__} [options] <input-file> [-- <compiler-opts>...]
       #{__FILE__} (-h | --help)
       #{__FILE__} --version

OPTIONS:
  -h, --help                           show this help message and exit
  --version                            show version and exit
  -o, --output EXECUTABLE              name of executable [default: main]
USAGESTR

require 'docopt'

tmp_file = nil

begin
  args = Docopt::docopt(doc, version: VERSION)

  in_file = args["<input-file>"]
  out_exe = args["--output"]

  if in_file == "-"
    tmp_file = read_into_tmp_file
    in_file = tmp_file.path
  end

  create_fresh_build_env(out_exe, BUILD_DIR)
  compile_file(absolute_path_for_module(in_file))
  run_gcc(out_exe, args["<compiler-opts>"])
rescue Docopt::Exit => e
  puts e.message
ensure
  tmp_file.unlink if tmp_file
end

# vim: ts=2 sw=2 :
