;; An in-memory representation and associated functions for the ELF file format.
;; The scope of this module is reduced by assuming system configuration such as
;; x86-64 little-endian systems.

;; CONSTRUCTORS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (empty-static-executable)
  (new-elf '()))

(define (new-elf stubs)
  (list 'elf stubs))

;; BUILDER FUNCTIONS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Add the given machine code (represented as an opaque list of bytes) into the
;; ELF file as the main code that will be executed when the ELF file is run.
;; This entails:
;;
;;   1. Ensuring the code is present in the final ELF file in a `.text` section.
;;   2. There is a `.text` section header for this section.
;;   3. There is a program header to ensure the code is loaded into memory.
;;   4. The entrypoint of the ELF file is set to wherever the above program
;;      header will place the code in memory.
;;
;; Note all of these will be finalized immediately, as references between
;; different parts of the file need to be finalized at the time of writing the
;; ELF file.
;;
;; @param elf - the in-progress ELF file structure
;; @param code-bytes - the list of bytes comprising the code
;; @return the updated ELF file structure
(define (add-executable-code elf code-bytes)
  (let* ((stubs (elf->stubs elf))
         (updated-stubs
           (append
             stubs
             (list
               (new-stub-text code-bytes)
               ; TODO - stub for section header
               ; TODO - stub for program header
               ))) )
    (new-elf updated-stubs)))

;; INTERNAL DATA STRUCTURES ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define elf->stubs (compose car cdr))

(define stub->type car)

(define (new-stub-text code-bytes)
  (list 'stub-text code-bytes))

; (define elf->sections (compose cdr car))
; (define elf->program-headers (compose cdr cdr car))
; 
; (define (located-byte-span byte-span offset)
;   (cons byte-span offset))
; (define located-byte-span->bytes car)
; (define located-byte-span->offset cdr)
; (define located-byte-span->length (compose located-byte-span->bytes length))
; (define (located-byte-span->offset-after span)
;   (+
;     (located-byte-span->offset span)
;     (located-byte-span->length span)))
; 
; (define section-type car)
; 
; (define (text-section code-bytes)
;   (cons 'text code-bytes))
; (define text-section->code-bytes cdr)

;; STUBS -> ELF DATA STRUCTURES ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (int->little-endian int pad-to-total-bytes)
  ; 0x12345678 -> 0x78 0x56 0x34 0x12
  ; 0x00005678 -> 0x78 0x56 0x00 0x00
  (define (convert-remaining-bytes reduced-int num-bytes-left)
    (if (= num-bytes-left 0)
      '()
      (cons
        (bitwise-and reduced-int 0xff)
        (convert-remaining-bytes
          (arithmetic-shift reduced-int -2)
          (- num-bytes-left 1)) ) ))

  (convert-remaining-bytes int pad-to-total-bytes))

(define (num-section-headers elf)
  (define (num-section-headers-for-stub stub)
    (let ((type (stub->type stub)))
      (cond ((= type 'stub-text) 1) ; Later, may contribute more sections
            (else 0)) ))

  ((compose
     (lambda (s) (+ s 1)) ; Always include an entry for the section header
                          ;   string table, which is needed because there is a
                          ;   section header table in the first place
     sum
     (lambda (stubs) (map num-section-headers-for-stub stubs))
     elf->stubs) elf))

(define (num-program-headers elf)
  (define (num-program-headers-for-stub stub)
    (let ((type (stub->type stub)))
      (cond ((= type 'stub-text) 1)
            (else 0)) ))

  ((compose
     sum
     (lambda (stubs) (map num-program-headers-for-stub stubs))
     elf->stubs) elf))

;; OUTPUT ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; TODO - document
(define (emit-as-bytes elf)
  (construct-header elf))

; TODO - there are two approaches to constructing the header:
;
; 1. Construct the header as a stub and fill in the details later, like all the
;    other sections.
; 2. Construct the header last, and pass in information from all the other
;    sections that have already been generated by this point. Currently, this is
;    the approach taken here, though passing in other information is still TBD.
(define (construct-header elf)
  (append
    (list
      0x7f 0x45 0x4c 0x46 ; Magic number
      0x02 ; 64-bit architecture
      0x01 ; Two's compliment, little-endian
      0x01 ; Current ELF specification version
      0x00 0x00 ; "None" OS/ABI, equiv. to UNIX - System-V, default version
      0x00 0x00 0x00 0x00 0x00 0x00 0x00 ; Padding until 16 bytes

      0x02 0x00 ; Static executable -- TODO: should depend on type of builder
      0x3e 0x00 ; AMD x86-64
      0x01 0x00 0x00 0x00) ; Current file version

    ; TODO: 8 bytes -- entry point
    (list 0xff 0xff 0xff 0xff 0xff 0xff 0xff 0xff)

    ; TODO: 8 bytes -- program header table start
    (list 0xfe 0xfe 0xfe 0xfe 0xfe 0xfe 0xfe 0xfe)

    ; TODO: 8 bytes -- section header table start
    (list 0xfd 0xfd 0xfd 0xfd 0xfd 0xfd 0xfd 0xfd)

    (list
      0x00 0x00 0x00 0x00 ;  Processsor-specific flags, none defined
      0x40 0x00) ; ELF header size

    (list 0x38 0x00) ; Program header entry size, 56 bytes for 64-bit
                     ; architectures
    (int->little-endian (num-program-headers elf) 2)

    (list 0x40 0x00) ; Section header entry size, 64 bytes for 64-bit
                     ; architectures
    (int->little-endian (num-section-headers elf) 2)

    ; TODO: 2 bytes -- section name string table index
    (list 0xfd 0xfd) ))

;; EXPORTS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(module-export
  ; Constructors
  empty-static-executable

  ; Builder functions
  add-executable-code

  ; Output
  emit-as-bytes)

;; TEMP: MAIN ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 
;; To be removed once the functionality has been tested, and the code generator
;; starts using this functionality.

(require "compiler_temp")

(define test-code
  '(0x48 0xc7 0xc0 0x3c 0x00 0x00 0x00 ; mov  $60, %rax
    0xbf 0x2a 0x00 0x00 0x00           ; mov  $42, %edi
    0x0f 0x05))                        ; syscall

((compose
   compiler_temp:print-bytes
   (lambda (e) (emit-as-bytes e))
   ; (lambda (e) (display e) (newline))
   (lambda (e) (add-executable-code e test-code)))
 (empty-static-executable))
